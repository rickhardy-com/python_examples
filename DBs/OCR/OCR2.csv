1,1,Content of Computer systems ,"This component will introduce learners to the internal workings of the Central Processing Unit (CPU), the exchange	of	data	and	will	also	look	at	software	development, data types and legal and ethical issues. It is expected that learners will draw on this underpinning	content	when	studying	computational	thinking, developing programming techniques and devising their own programming approach in the Programming project component (03 or 04). 
Learners will be expected to apply the criteria below in different	contexts	including	current	and	future	uses	of	the technologies",0
1,2,Content of Algorithms and programming ,"This component will incorporate and build on the
knowledge and understanding gained in the Computer
systems component (01).
In addition, learners should:
• understand what is meant by computational thinking
• understand the benefits of applying computational thinking to solving a wide variety of problems
• understand the principles of solving problems by computational methods
• be able to use algorithms to describe problems
• be able to analyse a problem by identifying its component parts.",0
1,3,Content of non exam assessment Programming project ,"Learners will be expected to analyse, design, develop, test, evaluate and document a program written in a suitable programming language. The underlying approach to the project is to apply the principles of computational thinking to a practical coding problem.
Learners are expected to apply appropriate principles from an agile development approach to the project development.
While the project assessment criteria are organised into specific categories, it is anticipated the final report will document the agile development process and elements for each of the assessment categories will appear throughout the report.",0
2,1.1," The characteristics of contemporary processors, input, output and storage devices",Components of a computer and their uses,1
2,1.2,Software and software development,Types of software and the different methodologies used to develop software,1
2,1.3,Exchanging data,How data is exchanged between different systems,1
2,1.4,"Data types, data structures and algorithms",How data is represented and stored within different structures. Different algorithms that can be applied to these structures,1
2,1.5," Legal, moral, cultural and ethical issues","The individual moral, social, ethical and cultural opportunities and risks of digital technology. Legislation surrounding the use of computers and ethical issues that can or may in the future arise from the use of computers",1
2,2.1,Elements of computational thinking,Understand what is meant by computational thinking,2
2,2.2, Problem solving and programming,How computers can be used to solve problems and programs can be written to solve them  (Learners will benefit from being able to program in a procedure/imperative language and object oriented language.),2
2,2.3,Algorithms,The use of algorithms to describe problems and standard algorithms,2
2,3.1,Analysis of the problem,10 Marks,3
2,3.2,Design of the solution,15 Marks,3
2,3.3,Developing the solution,25 marks,3
2,3.4,Evaluation,20 marks,3
3,1.1.1,Structure and function of the processor,,1.1
3,1.1.2,Types of processor,,1.1
3,1.1.3,"Input, output and storage",,1.1
3,1.2.1,Systems Software,,1.2
3,1.2.2,Applications Generation,,1.2
3,1.2.3,Software Development,,1.2
3,1.2.4,Types of Programming Language,,1.2
3,1.3.1,"Compression, Encryption and Hashing",,1.3
3,1.3.2,Databases,,1.3
3,1.3.3,Networks,,1.3
3,1.3.4,Web Technologies,,1.3
3,1.4.1,Data Types,,1.4
3,1.4.2,Data Structures,,1.4
3,1.4.3,Boolean Algebra,,1.4
3,1.5.1,Computing related legislation,,1.5
3,1.5.2,Moral and ethical Issues,,1.5
3,2.1.1,Thinking abstractly,,2.1
3,2.1.2,Thinking ahead,,2.1
3,2.1.3,Thinking procedurally,,2.1
3,2.1.4,Thinking logically,,2.1
3,2.1.5,Thinking concurrently,,2.1
3,2.2.1,Programming techniques,,2.2
3,2.2.2,Computational methods,,2.2
3,2.3.1,Algorithms,,2.3
3,3.1.1,Problem identification,,3.1
3,3.1.2,Stakeholders,,3.1
3,3.1.3,Research the problem,,3.1
3,3.1.4,Specify the proposed solution,,3.1
3,3.2.1,Decompose the problem,,3.2
3,3.2.2,Describe the solution,,3.2
3,3.2.3,Describe the approach to testing,,3.2
3,3.3.1,Iterative development process,,3.3
3,3.3.2,Testing to inform development,,3.3
3,3.4.1,Testing to inform evaluation,,3.4
3,3.4.2,Success of the solution,,3.4
3,3.4.3,Describe the final product,,3.4
3,3.4.4,Maintenance and development,,3.4
4,1.1.1.a,"The Arithmetic and Logic Unit; ALU, Control Unit and Registers (Program Counter; PC, Accumulator; ACC, Memory Address Register; MAR, Memory Data Register; MDR, Current Instruction Register; CIR). Buse",,1.1.1
4,1.1.1.b,The Fetch-Decode-Execute Cycle; including its effects on registers.,,1.1.1
4,1.1.1.c,"The factors affecting the performance of the CPU: clock speed, number of cores, cache.",,1.1.1
4,1.1.1.d,The use of pipelining in a processor to improve efficiency.,,1.1.1
4,1.1.1.e,"Von Neumann, Harvard and contemporary processor architecture.",,1.1.1
4,1.1.2.a,The differences between and uses of CISC and RISC processors.,,1.1.2
4,1.1.2.b,GPUs and their uses (including those not related to graphics).,,1.1.2
4,1.1.2.c,Multicore and Parallel systems.,,1.1.2
4,1.1.3.a,"How different input, output and storage devices can be applied to the solution of different problems.",,1.1.3
4,1.1.3.b,"The uses of magnetic, flash and optical storage devices.",,1.1.3
4,1.1.3.c,RAM and ROM.,,1.1.3
4,1.1.3.d,Virtual storage.,,1.1.3
4,1.2.1.a,"The need for, function and purpose of operating systems.",,1.2.1
4,1.2.1.b,"Memory Management (paging, segmentation and virtual memory).",,1.2.1
4,1.2.1.c,"Interrupts, the role of interrupts and Interrupt Service Routines (ISR), role within the Fetch-Decode-Execute Cycle.",,1.2.1
4,1.2.1.d,"Scheduling: round robin, first come first served, multi-level feedback queues, shortest job first and shortest remaining time.",,1.2.1
4,1.2.1.e,"Distributed, embedded, multi-tasking, multi-user and Real Time operating systems.",,1.2.1
4,1.2.1.f,BIOS.,,1.2.1
4,1.2.1.g,Device drivers.,,1.2.1
4,1.2.1.h,"Virtual machines, any instance where software is used to take on the function of a machine, including executing intermediate code or running an operating system within another.",,1.2.1
4,1.2.2.a,"The nature of applications, justifying suitable applications for a specific purpose.",,1.2.2
4,1.2.2.b,Utilities.,,1.2.2
4,1.2.2.c,Open source vs closed source.,,1.2.2
4,1.2.2.d,"Translators:Interpreters, compilers and assemblers.",,1.2.2
4,1.2.2.e,"Stages of compilation (lexical analysis, syntax analysis, code generation and optimisation).",,1.2.2
4,1.2.2.f,Linkers and loaders and use of libraries.,,1.2.2
4,1.2.3.a,"Understand the waterfall lifecycle, agile methodologies, extreme programming, the spiral model and rapid application development.",,1.2.3
4,1.2.3.b,The relative merits and drawbacks of different methodologies and when they might be used.,,1.2.3
4,1.2.3.c,Writing and following algorithms.,,1.2.3
4,1.2.4.a,Need for and characteristics of a variety of programming paradigms.,,1.2.4
4,1.2.4.b,Procedural languages.,,1.2.4
4,1.2.4.c,Assembly language (including following and writing simple programs with the Little Man Computer instruction set). See appendix 5d.,,1.2.4
4,1.2.4.d,"Modes of addressing memory (immediate, direct, indirect and indexed).",,1.2.4
4,1.2.4.e,"Object-oriented languages (see appendix 5d for pseudocode style) with an understanding of classes, objects, methods, attributes, inheritance, encapsulation and polymorphism.",,1.2.4
4,1.3.1.a,Lossy vs Lossless compression.,,1.3.1
4,1.3.1.b,Run length encoding and dictionary coding for lossless compression.,,1.3.1
4,1.3.1.c,Symmetric and asymmetric encryption.,,1.3.1
4,1.3.1.d,Different uses of hashing.,,1.3.1
4,1.3.2.a,"Relational database, flat file, primary key, foreign key, secondary key, entity relationship modelling, normalisation and indexing. See appendix 5f.",,1.3.2
4,1.3.2.b,"Methods of capturing, selecting, managing and exchanging data.",,1.3.2
4,1.3.2.c,Normalisation to 3NF.,,1.3.2
4,1.3.2.d,SQL – Interpret and modify. See appendix 5d.,,1.3.2
4,1.3.2.e,Referential integrity.,,1.3.2
4,1.3.2.f,"Transaction processing, ACID (Atomicity, Consistency, Isolation, Durability), record locking and redundancy.",,1.3.2
4,1.3.3.a,Characteristics of networks and the importance of protocols and standards.,,1.3.3
4,1.3.3.b,The internet structure:,,1.3.3
4,1.3.3.c,"Network security and threats, use of firewalls, proxies and encryption.",,1.3.3
4,1.3.3.d,Network hardware.,,1.3.3
4,1.3.3.e,Client-server and peer to peer.,,1.3.3
4,1.3.4.a,"HTML, CSS and JavaScript. See appendix 5d.",,1.3.4
4,1.3.4.b,Search engine indexing.,,1.3.4
4,1.3.4.c,PageRank algorithm.,,1.3.4
4,1.3.4.d,Server and client side processing.,,1.3.4
4,1.4.1.a,"Primitive data types, integer, real/floating point, character, string and Boolean.",,1.4.1
4,1.4.1.b,Represent positive integers in binary.,,1.4.1
4,1.4.1.c,Use of sign and magnitude and two’s complement to represent negative numbers in binary.,,1.4.1
4,1.4.1.d,Addition and subtraction of binary integers.(e) Represent positive integers in hexadecimal.,,1.4.1
4,1.4.1.f,Convert positive integers between binary hexadecimal and denary.,,1.4.1
4,1.4.1.g,Representation and normalisation of floating point numbers in binary.,,1.4.1
4,1.4.1.h,"Floating point arithmetic, positive and negative numbers, addition and subtraction.",,1.4.1
4,1.4.1.i,"Bitwise manipulation and masks: shifts, combining with AND, OR, and XOR.",,1.4.1
4,1.4.1.j,How character sets (ASCII and UNICODE) are used to represent text.,,1.4.1
4,1.4.2.a,"Arrays (of up to 3 dimensions), records, lists, tuples.",,1.4.2
4,1.4.2.b,"The following structures to store data: linked-list, graph (directed and undirected), stack, queue, tree, binary search tree, hash table.",,1.4.2
4,1.4.2.c,"How to create, traverse, add data to and remove data from the data structures mentioned above. (NB this can be either using arrays and procedural programming or an object-oriented approach).",,1.4.2
4,1.4.3.a,Define problems using Boolean logic. See appendix 5d.,,1.4.3
4,1.4.3.b,"Manipulate Boolean expressions, including the use of Karnaugh maps to simplify Boolean expressions.",,1.4.3
4,1.4.3.c,"Use the following rules to derive or simplify statements in Boolean algebra: De Morgan’s Laws, distribution, association, commutation, double negation.",,1.4.3
4,1.4.3.d,Using logic gate diagrams and truth tables. See appendix 5d.,,1.4.3
4,1.4.3.e,"The logic associated with D type flip flops, half and full adders.",,1.4.3
4,1.5.1.a,The Data Protection Act 1998.,,1.5.1
4,1.5.1.b,The Computer Misuse Act 1990.,,1.5.1
4,1.5.1.c,The Copyright Design and Patents Act 1988.,,1.5.1
4,1.5.1.d,The Regulation of Investigatory Powers Act 2000.,,1.5.1
4,1.5.2.a,"The individual moral, social, ethical and cultural opportunities and risks of digital technology:",,1.5.2
4,2.1.1.a,The nature of abstraction.,,2.1.1
4,2.1.1.b,The need for abstraction.,,2.1.1
4,2.1.1.c,The differences between an abstraction and reality.,,2.1.1
4,2.1.1.d,Devise an abstract model for a variety of situations.,,2.1.1
4,2.1.2.a,Identify the inputs and outputs for a given situation.,,2.1.2
4,2.1.2.b,Determine the preconditions for devising a solution to a problem.,,2.1.2
4,2.1.2.c,"The nature, benefits and drawbacks of caching.",,2.1.2
4,2.1.2.d,The need for reusable program components.,,2.1.2
4,2.1.3.a,Identify the components of a problem.,,2.1.3
4,2.1.3.b,Identify the components of a solution to a problem.,,2.1.3
4,2.1.3.c,Determine the order of the steps needed to solve a problem.,,2.1.3
4,2.1.3.d,Identify sub-procedures necessary to solve a problem.,,2.1.3
4,2.1.4.a,Identify the points in a solution where a decision has to be taken.,,2.1.4
4,2.1.4.b,Determine the logical conditions that affect the outcome of a decision.,,2.1.4
4,2.1.4.c,Determine how decisions affect flow through a program.,,2.1.4
4,2.1.5.a,Determine the parts of a problem that can be tackled at the same time.,,2.1.5
4,2.1.5.b,Outline the benefits and trade offs that might result from concurrent processing in a particular situation.,,2.1.5
4,2.2.1.a,"Programming constructs: sequence, iteration, branching.",,2.2.1
4,2.2.1.b,"Recursion, how it can be used and compares to an iterative approach.",,2.2.1
4,2.2.1.c,Global and local variables.,,2.2.1
4,2.2.1.d,"Modularity, functions and procedures, parameter passing by value and by reference.",,2.2.1
4,2.2.1.e,Use of an IDE to develop/debug a program.,,2.2.1
4,2.2.1.f,Use of object oriented techniques.,,2.2.1
4,2.2.2.a,Features that make a problem solvable by computational methods. (b) Problem recognition.,,2.2.2
4,2.2.2.c,Problem decomposition.,,2.2.2
4,2.2.2.d,Use of divide and conquer.,,2.2.2
4,2.2.2.e,Use of abstraction.,,2.2.2
4,2.2.2.f,Learners should apply their knowledge of:,,2.2.2
4,2.3.1.a,Analysis and design of algorithms for a given situation.,,2.3.1
4,2.3.1.b,"The suitability of different algorithms for a given task and data set, in terms of execution time and space.",,2.3.1
4,2.3.1.c,"Measures and methods to determine the efficiency of different algorithms, Big O notation (constant, linear, polynomial, exponential and logarithmic complexity).",,2.3.1
4,2.3.1.d,Comparison of the complexity of algorithms.,,2.3.1
4,2.3.1.e,"Algorithms for the main data structures, (stacks, queues, trees, linked lists, depth-first (post-order) and breadth-first traversal of trees).",,2.3.1
4,2.3.1.f,"Standard algorithms (bubble sort, insertion sort, merge sort, quick sort, Dijkstra’s shortest path algorithm, A* algorithm, binary search and linear search).",,2.3.1
4,3.1.1.a,Describe and justify the features that make the problem solvable by computational methods.,,3.1.1
4,3.1.1.b,Explain why the problem is amenable to a computational approach.,,3.1.1
4,3.1.2.a,"Identify and describe those who will have an interest in the solution explaining how the solution is appropriate to their needs (this may be named individuals, groups or persona that describes the tar",,3.1.2
4,3.1.3.a,Research the problem and solutions to similar problems to identify and justify suitable approaches to a solution. ,,3.1.3
4,3.1.3.b,Describe the essential features of a computational solution explaining these choices. ,,3.1.3
4,3.1.3.c,Explain the limitations of the proposed solution.,,3.1.3
4,3.1.4.a,Specify and justify the solution requirements including hardware and software configuration (if appropriate).,,3.1.4
4,3.1.4.b,Identify and justify measurable success criteria for the proposed solution.,,3.1.4
4,3.2.1.a,"Break down the problem into smaller parts suitable
for computational solutions justifying any decisions
made.",,3.2.1
4,3.2.2.a,Explain and justify the structure of the solution.,,3.2.2
4,3.2.2.b,Describe the parts of the solution using algorithms justifying how these algorithms form a complete solution to the problem.,,3.2.2
4,3.2.2.c,Describe usability features to be included in thesolution.,,3.2.2
4,3.2.2.d,Identify key variables / data structures / classes justifying choices and any necessary validation.,,3.2.2
4,3.2.3.a,Identify the test data to be used during the iterativedevelopment and post development phases andjustify the choice of this test data.,,3.2.3
4,3.3.1.a,Provide annotated evidence of each stage of the iterative development process justifying any decision made.,,3.3.1
4,3.3.1.b,Provide annotated evidence of prototype solutions justifying any decision made.,,3.3.1
4,3.3.2.a,Provide annotated evidence for testing at each stage justifying the reason for the test.,,3.3.2
4,3.3.2.b,Provide annotated evidence of any remedial actions taken justifying the decision made.,,3.3.2
4,3.4.1.a, Provide annotated evidence of testing the solution of robustness at the end of the development process.,,3.4.1
4,3.4.1.b, Provide annotated evidence of usability testing (user feedback).,,3.4.1
4,3.4.2.a,Use the test evidence from the development and post development process to evaluate the solution against the success criteria from the analysis.,,3.4.2
4,3.4.3.a,"Provide annotated evidence of the usability features from the design, commenting on their effectiveness.",,3.4.3
4,3.4.4.a, Discuss the maintainability of the solution.,,3.4.4
4,3.4.4.b, Discuss potential further development of the solution.,,3.4.4
5,1.3.3.b.1,The TCP/IP Stack.,,1.3.3.b
5,1.3.3.b.2,DNS,,1.3.3.b
5,1.3.3.b.3,Protocol layering.,,1.3.3.b
5,1.3.3.b.4,LANs and WANs.,,1.3.3.b
5,1.3.3.b.5,Packet and circuit switching.,,1.3.3.b
5,1.5.2.a.1,Computers in the workforce,,1.5.2.a
5,1.5.2.a.2, Automated decision making.,,1.5.2.a
5,1.5.2.a.3,Artificial intelligence.,,1.5.2.a
5,1.5.2.a.4,Environmental effects.,,1.5.2.a
5,1.5.2.a.5,Censorship and the Internet.,,1.5.2.a
5,1.5.2.a.6,Monitor behaviour.,,1.5.2.a
5,1.5.2.a.7,Analyse personal information.,,1.5.2.a
5,1.5.2.a.8,Piracy and offensive communications.,,1.5.2.a
5,1.5.2.a.9,"Layout, colour paradigms and character sets.",,1.5.2.a
5,2.2.2.f.1,backtracking,,2.2.2.f
5,2.2.2.f.2,data mining,,2.2.2.f
5,2.2.2.f.3,heuristics,,2.2.2.f
5,2.2.2.f.4,performance modelling,,2.2.2.f
5,2.2.2.f.5,pipelining,,2.2.2.f
5,2.2.2.f.6,visualisation to solve problems.,,2.2.2.f
